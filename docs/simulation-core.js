// simulation-core.js

window.simulateBattle = function simulateBattle(formData, resultDiv) {

  let playerLevel = parseInt(formData.playerLevel);
  const playerMaxLevel = parseInt(formData.playerMaxLevel);
  const baseAttack = parseFloat(formData.baseAttack);
  const attackC = parseFloat(formData.attackC);
  const baseCritChance = parseFloat(formData.critChance);
  const baseCritDamage = parseFloat(formData.critDamage);
  const baseAttackSpeed = parseFloat(formData.attackSpeed);

  const baseResource = parseFloat(formData.baseResource);
  const resourceInterval = parseFloat(formData.resourceInterval);

  const initialEnemyLevel = parseInt(formData.enemyLevel);
  const enemyMaxLevel = parseInt(formData.enemyMaxLevel);
  const enemyBaseHP = parseFloat(formData.enemyHP);
  const enemyBaseDef = parseFloat(formData.enemyBaseDef);
  const hpGrowthRate = parseFloat(formData.hpGrowthRate);
  const defC = parseFloat(formData.defC);
  const defE = parseFloat(formData.defE);
  const rewardBase = parseFloat(formData.rewardBase);
  const rewardCostC = parseFloat(formData.rewardCostC);
  const maxTime = parseFloat(formData.maxTime);
  const maxKill = parseInt(formData.maxKill);

  const upgradeCostLevel = parseFloat(formData.upgradeCostLevel);
  const upgradeCostAttack = parseFloat(formData.upgradeCostAttack);
  const upgradeCostSpeed = parseFloat(formData.upgradeCostSpeed);
  const upgradeCostCritChance = parseFloat(formData.upgradeCostCritChance);
  const upgradeCostCritDamage = parseFloat(formData.upgradeCostCritDamage);

  const levelCostC = parseFloat(formData.levelCostC);
  const attackCostC = parseFloat(formData.attackCostC);
  const speedCostC = parseFloat(formData.speedCostC);
  const critChanceCostC = parseFloat(formData.critChanceCostC);
  const critDamageCostC = parseFloat(formData.critDamageCostC);

  const maxAttackLevel = parseInt(formData.maxAttackLevel);
  const maxSpeedLevel = parseInt(formData.maxSpeedLevel);
  const maxCritChanceLevel = parseInt(formData.maxCritChanceLevel);
  const maxCritDamageLevel = parseInt(formData.maxCritDamageLevel);

  let attackLevel = 0, speedLevel = 0, critChanceLevel = 0, critDamageLevel = 0;

  function calcUpgradeCost(baseCost, costC, level) {
    return baseCost * Math.pow(costC, level);
  }

  const strategy = formData.strategyType || 'balanced';
  const weights = {
	  level: parseFloat(document.getElementById(`${strategy}LevelUp`).value),
	  attack: parseFloat(document.getElementById(`${strategy}Attack`).value),
	  critChance: parseFloat(document.getElementById(`${strategy}CritChance`).value),
	  critDamage: parseFloat(document.getElementById(`${strategy}CritDamage`).value),
	  speed: parseFloat(document.getElementById(`${strategy}Speed`).value)
  };

  let totalTime = 0, killCount = 0, attackCount = 0, resource = 0;
  let totalResource = 0;
  let nextResourceTime = resourceInterval, totalDamageDealt = 0;
  let currentEnemyLevel = initialEnemyLevel;
  let enemyHP = enemyBaseHP * Math.pow(hpGrowthRate, currentEnemyLevel - 1);
  let enemyDefense = enemyBaseDef * Math.pow(defE, defC * (currentEnemyLevel - 1));
  const battleLogsHtml = [];
  let currentEnemyLog = [];
  const powerTimeline = [];
  const upgradeTimeline = [];

  while (totalTime < maxTime && killCount < maxKill) {
    while (totalTime >= nextResourceTime) {
      const gain = baseResource * playerLevel;
      resource += gain;
	  totalResource += gain;
      currentEnemyLog.push(`<span class="resource-log" style="color: green; font-weight: bold;">üí∞ ÏãúÍ∞Ñ ${nextResourceTime.toFixed(2)}Ï¥à: Ïû¨Ìôî ${gain.toFixed(2)} ÌöçÎìù  (ÎàÑÏ†Å Ïû¨Ìôî: ${totalResource.toFixed(2)})</span>`);
      nextResourceTime += resourceInterval;
    }

	function getRandomWeightedStat(weights) {
	  const entries = [
		{ key: 'level', weight: weights.level },
		{ key: 'attack', weight: weights.attack },
		{ key: 'speed', weight: weights.speed },
		{ key: 'critChance', weight: weights.critChance },
		{ key: 'critDamage', weight: weights.critDamage }
	  ];

	  const total = entries.reduce((sum, e) => sum + e.weight, 0);
	  const rand = Math.random() * total;
	  let acc = 0;

	  for (const entry of entries) {
		acc += entry.weight;
		if (rand <= acc) return entry.key;
	  }
	  return entries[0].key; // fallback
	}
	
	 let currentUpgrade = {
      time: totalTime.toFixed(2),
      level: playerLevel,
      attack: attackLevel,
      speed: speedLevel,
      critChance: critChanceLevel,
      critDamage: critDamageLevel
    };
	
	let upgradeAttempted = true;
	while (resource > 0 && upgradeAttempted) {
	  upgradeAttempted = false;  // Î®ºÏ†Ä falseÎ°ú ÏÑ§Ï†ï
	  const statType = getRandomWeightedStat(weights);

	  switch (statType) {
		case 'level':
		  if (playerLevel < playerMaxLevel) {
			const cost = calcUpgradeCost(upgradeCostLevel, levelCostC, playerLevel);
			if (resource >= cost) {
			  resource -= cost;
			  currentEnemyLog.push(`<span class="resource-log" style="color: green; font-weight: bold;">‚ú® Î†àÎ≤® ÏóÖÍ∑∏Î†àÏù¥Îìú! ‚Üí (${playerLevel} -> ${playerLevel+1}) Î†àÎ≤® (ÎπÑÏö©: ${cost.toFixed(2)})</span>`);		
			  playerLevel++;	
              currentUpgrade.level = playerLevel;  
			}
		  }
		  break;
		case 'attack':
		  if (attackLevel < maxAttackLevel) {
			const cost = calcUpgradeCost(upgradeCostAttack, attackCostC, attackLevel);
			if (resource >= cost) {
			  resource -= cost;
			  currentEnemyLog.push(`<span class="resource-log" style="color: green; font-weight: bold;">‚ú® Í≥µÍ≤©Î†• ÏóÖÍ∑∏Î†àÏù¥Îìú! ‚Üí (${attackLevel} -> ${attackLevel+1})}Î†àÎ≤® (ÎπÑÏö©: ${cost.toFixed(2)})</span>`);	
			  attackLevel++;	
              currentUpgrade.attack = attackLevel;
			}
		  }
		  break;

		case 'speed':
		  if (speedLevel < maxSpeedLevel) {
			const cost = calcUpgradeCost(upgradeCostSpeed, speedCostC, speedLevel);
			if (resource >= cost) {
			  resource -= cost;
			  currentEnemyLog.push(`<span class="resource-log" style="color: green; font-weight: bold;">‚ú® Í≥µÍ≤©ÏÜçÎèÑ ÏóÖÍ∑∏Î†àÏù¥Îìú! ‚Üí (${speedLevel} -> ${speedLevel+1})Î†àÎ≤® (ÎπÑÏö©: ${cost.toFixed(2)})</span>`);
			  speedLevel++;
              currentUpgrade.speed = speedLevel;
			}
		  }
		  break;

		case 'critChance':
		  if (critChanceLevel < maxCritChanceLevel) {
			const cost = calcUpgradeCost(upgradeCostCritChance, critChanceCostC, critChanceLevel);
			if (resource >= cost) {
			  resource -= cost;
			  currentEnemyLog.push(`<span class="resource-log" style="color: green; font-weight: bold;">‚ú® ÌÅ¨Î¶¨ ÌôïÎ•† ÏóÖÍ∑∏Î†àÏù¥Îìú! ‚Üí (${critChanceLevel} -> ${critChanceLevel+1})Î†àÎ≤® (ÎπÑÏö©: ${cost.toFixed(2)})</span>`);
			  critChanceLevel++;
              currentUpgrade.critChance = critChanceLevel;
			}
		  }
		  break;

		case 'critDamage':
		  if (critDamageLevel < maxCritDamageLevel) {
			const cost = calcUpgradeCost(upgradeCostCritDamage, critDamageCostC, critDamageLevel);
			if (resource >= cost) {
			  resource -= cost;
			  currentEnemyLog.push(`<span class="resource-log" style="color: green; font-weight: bold;">‚ú® ÌÅ¨Î¶¨ Îç∞ÎØ∏ÏßÄ ÏóÖÍ∑∏Î†àÏù¥Îìú! ‚Üí (${critDamageLevel} -> ${critDamageLevel+1})Î†àÎ≤® (ÎπÑÏö©: ${cost.toFixed(2)})</span>`);
			  critDamageLevel++;
              currentUpgrade.critDamage = critDamageLevel;
			}
		  }
		  break;
	  }
	}

    attackCount++;
    const rawAttack = (baseAttack + (attackLevel * 0.2)) * Math.log(playerLevel + 1) * attackC;
    const playerCritChance = Math.min(baseCritChance + playerLevel + critChanceLevel, 100);
    const playerCritDamage = baseCritDamage + playerLevel * 0.5 + critDamageLevel * 0.5;
    const playerAttackSpeed = baseAttackSpeed + (playerLevel + speedLevel) / 10;
    const attackInterval = 1 / playerAttackSpeed;

    const attackAfterDefense = rawAttack * (1 / (1 + enemyDefense / 100));
    const isCrit = Math.random() * 100 < playerCritChance;
    const finalDamage = isCrit ? attackAfterDefense * playerCritDamage : attackAfterDefense;

    enemyHP -= finalDamage;
    totalTime += attackInterval;
    totalDamageDealt += finalDamage;
	
	const maxEnemyHP = enemyBaseHP * Math.pow(hpGrowthRate, currentEnemyLevel - 1);
	const upgradedBaseAttack = baseAttack + (attackLevel * 0.2);
	const formattedLog = `
	[Í≥µÍ≤© ${attackCount}ÌöåÏ∞®] ‚è±Ô∏è ÏãúÍ∞Ñ: ${totalTime.toFixed(2)}Ï¥à
	‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ï∫êÎ¶≠ÌÑ∞ ÏÉÅÌÉú ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
	‚îÇ Î†àÎ≤®:           ${playerLevel}
	‚îÇ Í≥µÍ≤©Î†•:         Í∏∞Î≥∏ ${upgradedBaseAttack.toFixed(2)} ‚Üí Í≥ÑÏÇ∞ ${rawAttack.toFixed(2)} ‚Üí Î∞©Ïñ¥ ÌõÑ ${attackAfterDefense.toFixed(2)}
	‚îÇ Í≥µÍ≤©ÏÜçÎèÑ:       ${playerAttackSpeed.toFixed(2)} Ìöå/Ï¥à
	‚îÇ ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•†:   ${playerCritChance.toFixed(2)}%
	‚îÇ ÌÅ¨Î¶¨Ìã∞Ïª¨ Îç∞ÎØ∏ÏßÄ: ${playerCritDamage.toFixed(2)}Î∞∞
	‚îÇ Î≥¥Ïú† Ïû¨Ìôî:       ${resource.toFixed(2)}
	‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
	‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ï†Å ÏÉÅÌÉú ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
	‚îÇ Î†àÎ≤®:    ${currentEnemyLevel}
	‚îÇ Ï≤¥Î†•:    ${maxEnemyHP.toFixed(2)} ‚Üí ${enemyHP.toFixed(2)}
	‚îÇ Î∞©Ïñ¥Î†•:  ${enemyDefense.toFixed(2)}
	‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

	üí• ÏûÖÌûå Îç∞ÎØ∏ÏßÄ: ${finalDamage.toFixed(2)} ${isCrit ? '(ÌÅ¨Î¶¨Ìã∞Ïª¨!)' : '(ÏùºÎ∞ò Í≥µÍ≤©)'}
	`;

	currentEnemyLog.push(`<pre>${formattedLog}</pre>`);



    if (enemyHP <= 0) {
      killCount++;
      const rewardAmount = rewardBase * Math.pow(rewardCostC, killCount - 1);
      resource += rewardAmount;
	  totalResource += rewardAmount;
      currentEnemyLog.push(`<span class="kill" style="color: green; font-weight: bold;">‚úÖ Ï†Å Ï≤òÏπò ÏôÑÎ£å ${rewardAmount.toFixed(2)}  (ÎàÑÏ†Å Ïû¨Ìôî: ${totalResource.toFixed(2)}) ÌöçÎìù (${killCount}ÎßàÎ¶¨)</span>`);

      battleLogsHtml.push(`
<details>
  <summary>üê≤ ${killCount}Î≤àÏß∏ Ï†Å Ï≤òÏπò (Î†àÎ≤® ${currentEnemyLevel}, ÏãúÍ∞Ñ ${totalTime.toFixed(2)}Ï¥à)</summary>
  <pre>${currentEnemyLog.join('\n')}</pre>
</details>
      `);
      currentEnemyLog = [];

    const combatPower1 = 
	  (rawAttack ** 1.1) * 0.8  // Í≥µÍ≤©Î†• ÏßÄÏàò Ï¶ùÍ∞Ä Î∞òÏòÅ
	  * (1 + playerCritChance / 150)  // ÌÅ¨Î¶¨ ÌôïÎ•† ÏòÅÌñ• Í∞ÄÏ§ë(Í≥ºÎèÑÌïòÏßÄ ÏïäÍ≤å)
	  * (1 + playerCritDamage / 50)   // ÌÅ¨Î¶¨ Îç∞ÎØ∏ÏßÄ Í∞ÄÏ§ë
	  * Math.log(playerLevel + 2)     // Î†àÎ≤® Î°úÍ∑∏ ÏÑ±Ïû•
	  + playerAttackSpeed * 30        // Í≥µÍ≤©ÏÜçÎèÑÎäî Ìï©ÏÇ∞ÏúºÎ°ú Î≥¥Ï°∞ Í∞ÄÏ§ëÏπò
	  + playerLevel * 15;             // Î†àÎ≤® ÏÉÅÏàò Í∞ÄÏ§ëÏπò Ï∂îÍ∞Ä

	
    const expectedDmg = rawAttack * (1 + Math.min(playerCritChance, 100) / 100 * (playerCritDamage - 1));
	// Í≥µÍ≤©ÏÜçÎèÑÏôÄ Í∏∞ÎåÄÎç∞ÎØ∏ÏßÄ Í≥±Ïóê ÏßÄÏàò ÏÑ±Ïû• Î∞òÏòÅ
	const combatPower2 = 
	  expectedDmg * (playerAttackSpeed ** 1.2) * 12  // Í≥µÍ≤©ÏÜçÎèÑ ÏßÄÏàòÏ†Å ÏòÅÌñ• Î∞òÏòÅ
	  * Math.log(playerLevel + 2)                   // Î†àÎ≤® Î°úÍ∑∏ ÏÑ±Ïû• Î∞òÏòÅ
	  + Math.pow(playerLevel, 1.3) * 10;             // Î†àÎ≤® ÏßÄÏàò Í∞ÄÏ§ëÏπò Ï∂îÍ∞Ä

    const combatPower3 = totalDamageDealt;

      powerTimeline.push({
        time: totalTime.toFixed(2),
        combat1: combatPower1,
        combat2: combatPower2,
        combat3: combatPower3,
		level: playerLevel,
		attack: attackLevel,
		speed: speedLevel,
		critChance: critChanceLevel,
		critDamage: critDamageLevel
      });
	  
	  upgradeTimeline.push(currentUpgrade);

      if (currentEnemyLevel < enemyMaxLevel) currentEnemyLevel++;
      enemyHP = enemyBaseHP * Math.pow(hpGrowthRate, currentEnemyLevel - 1);
      enemyDefense = enemyBaseDef * Math.pow(defE, defC * (currentEnemyLevel - 1));
    }
  }

	const summaryData1 = {
	 'Ï¥ù ÏÇ¨ÎÉ• ÏãúÍ∞Ñ(Ï¥à)': totalTime,
	 'ÏµúÏ¢Ö Ïû¨Ìôî': totalResource
	};

	const summaryData2 = {
	  'Ï¥ù Ï≤òÏπò Ïàò': killCount,
	  'ÏµúÏ¢Ö ÎÇ¥ Î†àÎ≤®': playerLevel,
	  'ÏµúÏ¢Ö Ï†Å Î†àÎ≤®': currentEnemyLevel
	};

	resultDiv.innerHTML = `
	<details style="margin-top: 20px;">
	  <summary style="cursor: pointer; font-weight: bold;">üìä Ï†ÑÌà¨ Í≤∞Í≥º ÏöîÏïΩ</summary>
	  <div style="margin-top: 10px;">
		<strong>ÏãúÎÆ¨Î†àÏù¥ÏÖò Í≤∞Í≥º ÏöîÏïΩ</strong>
		<canvas id="summaryChart1" style="max-width: 100%; height: 400px; margin-bottom: 20px;"></canvas>
		<canvas id="summaryChart2" style="max-width: 100%; height: 400px; margin-bottom: 20px;"></canvas>

		<strong>Ï†ÑÌà¨Î†• Î≥ÄÌôî Ï∂îÏù¥</strong>
		<div style="position: relative;">
		  <canvas id="powerChart" style="max-width: 100%; height: 400px; margin-bottom: 20px;"></canvas>
		  <div id="yLevelLegend"
			 style="position: absolute; right: -180px; top: 60px;
					font-weight: bold; background: white;
					padding: 8px 12px; border-radius: 6px;
					box-shadow: 0 0 4px rgba(0,0,0,0.15);">
		  </div>
		</div>
		<label><input type="checkbox" id="toggleLevelGraphs" checked /> Î†àÎ≤®ÏóÖ Í∑∏ÎûòÌîÑ Î≥¥Í∏∞</label>

		<details style="margin-top: 15px;">
		  <summary style="cursor: pointer; font-weight: bold;">üìù Ï†ÑÏ≤¥ Ï†ÑÌà¨ Î°úÍ∑∏</summary>
		  <div id="battleLog" style="max-height: 500px; overflow-y:auto; border:1px solid #ccc; padding:10px; margin-top:10px;">
			${battleLogsHtml.join('\n')}
		  </div>
		</details>
	  </div>
	</details>
	<hr style="margin: 30px 0; border: none; border-top: 2px dashed #ccc;" />
	`;

	// Î†àÎ≤®ÏóÖ Í∑∏ÎûòÌîÑ ON / OFF
	document.getElementById('toggleLevelGraphs').addEventListener('change', (e) => {
	  const showLevels = e.target.checked;
	  if (!window.powerChartInstance) return;
	  window.powerChartInstance.data.datasets.forEach(dataset => {
		if (['Ï∫êÎ¶≠ÌÑ∞ Î†àÎ≤®', 'Í≥µÍ≤©Î†• Î†àÎ≤®', 'Í≥µÍ≤©ÏÜçÎèÑ Î†àÎ≤®', 'ÌÅ¨Î¶¨ ÌôïÎ•† Î†àÎ≤®', 'ÌÅ¨Î¶¨ Îç∞ÎØ∏ÏßÄ Î†àÎ≤®'].includes(dataset.label)) {
		  dataset.hidden = !showLevels;  // Ï≤¥ÌÅ¨Î∞ïÏä§ Ï≤¥ÌÅ¨ Ïãú Î≥¥Ïù¥Í≥†, Ìï¥Ï†ú Ïãú Ïà®Í∏∞Í∏∞
		}
	  });
	  window.powerChartInstance.update();
	});

  // summaryChart1 Ï∂îÍ∞Ä Î†åÎçîÎßÅ
  const ctx1 = document.getElementById('summaryChart1').getContext('2d');
  if (window.summaryChartInstance) window.summaryChartInstance.destroy();
  window.summaryChartInstance = new Chart(ctx1, {
    type: 'bar',
    data: {
      labels: Object.keys(summaryData1),
      datasets: [
        {
          label: 'ÏãúÎÆ¨Î†àÏù¥ÏÖò Í≤∞Í≥º',
          data: Object.values(summaryData1).map(v => +v.toFixed(2)),
          backgroundColor: 'rgba(54, 162, 235, 0.6)',
          borderColor: 'rgba(54, 162, 235, 1)',
          borderWidth: 1
        }
      ]
    },
    options: {
      responsive: true,
      scales: {
        x: { title: { display: true, text: 'ÏöîÏïΩ ÏßÄÌëú' } },
        y: {
          title: { display: true, text: 'Í∞í' },
          beginAtZero: true
        }
      }
    }
  });  
  
  // ÏÉà Ï∫îÎ≤ÑÏä§(Ïòà: summaryChart2) ÎßåÎì§Ïñ¥Ïïº Ìï®
	const ctx2 = document.getElementById('summaryChart2').getContext('2d');
	if (window.summaryChartInstance2) window.summaryChartInstance2.destroy();
	window.summaryChartInstance2 = new Chart(ctx2, {
	  type: 'bar',
	  data: {
		labels: Object.keys(summaryData2),
		datasets: [{
		  label: 'ÏãúÎÆ¨Î†àÏù¥ÏÖò Í≤∞Í≥º',
		  data: Object.values(summaryData2).map(v => +v.toFixed(2)),
		  backgroundColor: 'rgba(255, 159, 64, 0.6)',
		  borderColor: 'rgba(255, 159, 64, 1)',
		  borderWidth: 1
		}]
	  },
	  options: {
		responsive: true,
		scales: {
		  x: { title: { display: true, text: 'ÏöîÏïΩ ÏßÄÌëú' } },
		  y: { beginAtZero: true, title: { display: true, text: 'Í∞í' } }
		}
	  }
	});

  // powerChart Î†åÎçîÎßÅ Ïú†ÏßÄ
  const powerCtx = document.getElementById('powerChart').getContext('2d');
  if (window.powerChartInstance) window.powerChartInstance.destroy();
  const annotations = {};
  
  
  const showLevelGraphs = document.getElementById('toggleLevelGraphs')?.checked ?? true;

  // datasets Î∞∞Ïó¥ Ï§ÄÎπÑ
  const datasets = [
    {
      label: 'Ï†ÑÌà¨Î†•1 (Ìï©ÏÇ∞)',
      data: powerTimeline.map(p => p.combat1),
      borderColor: 'blue',
      yAxisID: 'yPower',
      fill: false,
      tension: 0.3
    },
    {
      label: 'Ï†ÑÌà¨Î†•2 (DPSÍ∏∞Î∞ò)',
      data: powerTimeline.map(p => p.combat2),
      borderColor: 'green',
      yAxisID: 'yPower',
      fill: false,
      tension: 0.3
    },
    {
      label: 'Ï†ÑÌà¨Î†•3 (ÎàÑÏ†ÅÌîºÌï¥)',
      data: powerTimeline.map(p => p.combat3),
      borderColor: 'red',
      yAxisID: 'yPower',
      fill: false,
      tension: 0.3
    }
  ];

  if (showLevelGraphs) {
    datasets.push(
      {
        label: 'Ï∫êÎ¶≠ÌÑ∞ Î†àÎ≤®',
        data: upgradeTimeline.map(p => p.level),
        borderColor: 'blue',
		borderWidth: 1,  
        yAxisID: 'yLevel',
        fill: false,
        tension: 0.3
      },
      {
        label: 'Í≥µÍ≤©Î†• Î†àÎ≤®',
        data: upgradeTimeline.map(p => p.attack),
        borderColor: 'red',
		borderWidth: 1,  
        yAxisID: 'yLevel',
        fill: false,
        tension: 0.3
      },
      {
        label: 'Í≥µÍ≤©ÏÜçÎèÑ Î†àÎ≤®',
        data: upgradeTimeline.map(p => p.speed),
        borderColor: 'orange',
		borderWidth: 1,  
        yAxisID: 'yLevel',
        fill: false,
        tension: 0.3
      },
      {
        label: 'ÌÅ¨Î¶¨ ÌôïÎ•† Î†àÎ≤®',
        data: upgradeTimeline.map(p => p.critChance),
        borderColor: 'green',
		borderWidth: 1,  
        yAxisID: 'yLevel',
        fill: false,
        tension: 0.3
      },
      {
        label: 'ÌÅ¨Î¶¨ Îç∞ÎØ∏ÏßÄ Î†àÎ≤®',
        data: upgradeTimeline.map(p => p.critDamage),
        borderColor: 'purple',
		borderWidth: 1,  
        yAxisID: 'yLevel',
        fill: false,
        tension: 0.3
      }
    );
  }
  
  window.powerChartInstance = new Chart(powerCtx, {
    type: 'line',
    data: {
      labels: powerTimeline.map(p => p.time),
      datasets: datasets
    },
    options: {
      responsive: true,
      scales: {
        x: {
          title: { display: true, text: 'ÏãúÍ∞Ñ (Ï¥à)' }
        },
        yPower: {
          type: 'linear',
          position: 'left',
          title: { display: true, text: 'Ï†ÑÌà¨Î†• ÏàòÏπò' },
          beginAtZero: true
        },
        yLevel: {
          type: 'linear',
          position: 'right',
          title: { display: true, text: 'Î†àÎ≤® ÏàòÏπò' },
          beginAtZero: true,
          min: 0,
          max: 100,
          grid: { drawOnChartArea: false }
        }
      },
      plugins: {
		legend: {
			labels: {
			  filter: function(legendItem, chartData) {
				// legendItem.textÍ∞Ä Î†àÏ†ÑÎìú ÌÖçÏä§Ìä∏
				// Ï†ÑÌà¨Î†•1,2,3ÏùÄ Î≥¥Ïó¨Ï£ºÍ≥† ÎÇòÎ®∏ÏßÄÎäî Ïà®ÍπÄ
				return ['Ï†ÑÌà¨Î†•1 (Ìï©ÏÇ∞)', 'Ï†ÑÌà¨Î†•2 (DPSÍ∏∞Î∞ò)', 'Ï†ÑÌà¨Î†•3 (ÎàÑÏ†ÅÌîºÌï¥)'].includes(legendItem.text);
			  }
			}
		},
        annotation: { annotations }
      }
    }
  });
  
  const yLevelLegend = document.getElementById('yLevelLegend');
	yLevelLegend.innerHTML = `
	  <div style="color: rgba(0,0,255,0.8); margin-bottom: 4px;">‚ñ† Ï∫êÎ¶≠ÌÑ∞ Î†àÎ≤®</div>
	  <div style="color: rgba(255,0,0,0.8); margin-bottom: 4px;">‚ñ† Í≥µÍ≤©Î†• Î†àÎ≤®</div>
	  <div style="color: rgba(255,165,0,0.8); margin-bottom: 4px;">‚ñ† ÏÜçÎèÑ Î†àÎ≤®</div>
	  <div style="color: rgba(0,128,0,0.8); margin-bottom: 4px;">‚ñ† ÌÅ¨Î¶¨ ÌôïÎ•† Î†àÎ≤®</div>
	  <div style="color: rgba(128,0,128,0.8); margin-bottom: 4px;">‚ñ† ÌÅ¨Î¶¨ Îç∞ÎØ∏ÏßÄ Î†àÎ≤®</div>
	`;
}
